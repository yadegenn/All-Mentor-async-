app = Quart(__name__)
app = cors(app, allow_origin=["*"], allow_headers=[
    "Content-Type",
    "Accept",
    "Telegram-Web-App-Init-Data",
    "telegram-web-app-init-data-hash"
])

@app.route('/api/send-form', methods=['POST'])
async def send_form():
    try:
        data = await request.get_json()
        logging.info(f"Received form data: {data}")

        user_id = data.get('userId')
        if not user_id:
            logging.error("No userId provided")
            return {
                "status": "error",
                "message": "User ID is required"
            }, 400

        db = await aiosqlite.connect(db_path)
        try:
            async with db.execute('SELECT topic_id FROM users WHERE chat_id = ?', (user_id,)) as cursor:
                row = await cursor.fetchone()
                logging.info(f"Database query result for user {user_id}: {row}")

                has_topic = bool(row)
                if row:
                    try:
                        await bot.get_forum_topic(GROUP_ID, row[0])
                        logging.info(f"Valid topic found for user {user_id}")
                    except Exception as e:
                        logging.error(f"Error checking forum topic: {str(e)}")
                        has_topic = False
        finally:
            await db.close()

        if not has_topic:
            logging.info(f"No valid topic for user {user_id}, checking required fields")
            required_fields = []
            if data['service'] == '–†–∞—Å—Å—ã–ª–∫–∞ –≤–∞—à–∏—Ö –±–∏—Ç–æ–≤':
                required_fields.append('mailCount')
            elif data['service'] == '–ö–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—è –ø–æ –º–µ–π–ª-–º–∞—Ä–∫–µ—Ç–∏–Ω–≥—É':
                required_fields.append('consultationType')
            elif data['service'] == '–ö—É–ø–∏—Ç—å –ø–æ—á—Ç—ã –∞—Ä—Ç–∏—Å—Ç–æ–≤ / –ø—Ä–æ–¥—é—Å–µ—Ä–æ–≤':
                required_fields.extend(['emailType', 'selectedOption'])

            missing_fields = [field for field in required_fields if not data.get(field)]
            if missing_fields:
                logging.error(f"Missing required fields: {missing_fields}")
                return {
                    "status": "error",
                    "message": f"–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –∑–∞–ø–æ–ª–Ω–∏—Ç—å —Å–ª–µ–¥—É—é—â–∏–µ –ø–æ–ª—è: {', '.join(missing_fields)}"
                }, 400

        db_main = await aiosqlite.connect(db_path)
        async with db_main.execute('SELECT topic_id FROM users WHERE chat_id = ?', (user_id,)) as cursor:
            row = await cursor.fetchone()
            if row:
                topic_id = row[0]
            else:
                topic_name = html.escape(data.get('firstName', 'Unknown User'))
                forum_topic = await bot.create_forum_topic(GROUP_ID, topic_name)
                topic_id = forum_topic.message_thread_id
                await db_main.execute('''
                    INSERT INTO users (chat_id, topic_id, user_name)
                    VALUES (?, ?, ?)
                ''', (user_id, topic_id, topic_name))
                await db_main.commit()

        # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —É—Å–ª—É–≥–∏
        message = f"""
üéØ –ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞!

–û—Ç: {data.get('firstName', 'Unknown User')} (ID: {data.get('userId', 'Unknown')})
–£—Å–ª—É–≥–∞: {data.get('service', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}"""

        if data['service'] == '–†–∞—Å—Å—ã–ª–∫–∞ –≤–∞—à–∏—Ö –±–∏—Ç–æ–≤':
            message += f"""
–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—á—Ç: {data.get('mailCount', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}
–¢–∏–ø: {data.get('type', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}
–°—Ç–æ–∏–º–æ—Å—Ç—å: {data.get('price', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}"""

        elif data['service'] == '–ö–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—è –ø–æ –º–µ–π–ª-–º–∞—Ä–∫–µ—Ç–∏–Ω–≥—É':
            message += f"""
–¢–∏–ø –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏–∏: {data.get('consultationType', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}
–°—Ç–æ–∏–º–æ—Å—Ç—å: {data.get('price', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}"""

        elif data['service'] == '–ö—É–ø–∏—Ç—å –ø–æ—á—Ç—ã –∞—Ä—Ç–∏—Å—Ç–æ–≤ / –ø—Ä–æ–¥—é—Å–µ—Ä–æ–≤':
            message += f"""
–¢–∏–ø –ø–æ—á—Ç: {data.get('emailType', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}
–í—ã–±—Ä–∞–Ω–æ: {data.get('selectedOption', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}
–°—Ç–æ–∏–º–æ—Å—Ç—å: {data.get('price', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}"""
            # –î–æ–±–∞–≤–ª—è–µ–º –∂–∞–Ω—Ä —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ –ø–æ—á—Ç—ã –∞—Ä—Ç–∏—Å—Ç–æ–≤ BeatStars
            if 'BeatStars' in data.get('emailType', ''):
                message += f"\n–ñ–∞–Ω—Ä: {data.get('genre', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}"

        try:
            await bot.send_message(
                GROUP_ID,
                message,
                message_thread_id=topic_id,
                parse_mode='HTML'
            )
        except Exception as e:
            if "message thread not found" in str(e):
                topic_name = html.escape(data.get('firstName', 'Unknown User'))
                forum_topic = await bot.create_forum_topic(GROUP_ID, topic_name)
                new_topic_id = forum_topic.message_thread_id

                await db_main.execute('''
                    UPDATE users
                    SET topic_id = ?
                    WHERE chat_id = ?
                ''', (new_topic_id, user_id))
                await db_main.commit()

                await db_main.execute('DELETE FROM group_messages WHERE topic_id = ?', (topic_id,))
                await db_main.commit()

                await bot.send_message(
                    GROUP_ID,
                    message,
                    message_thread_id=new_topic_id,
                    parse_mode='HTML'
                )

        try:
            await bot.send_message(
                user_id,
                "‚úÖ –ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞, –æ–∂–∏–¥–∞–π—Ç–µ –æ—Ç–≤–µ—Ç–∞"
            )
            logging.info(f"Confirmation message sent to user {user_id}")
        except Exception as e:
            error_msg = f"Error sending confirmation to user: {str(e)}"
            logging.error(error_msg)
            return {
                "status": "error",
                "message": "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ. –í–æ–∑–º–æ–∂–Ω–æ, –±–æ—Ç –Ω–µ –∑–∞–ø—É—â–µ–Ω"
            }, 400

        return {"status": "success"}, 200

    except Exception as e:
        error_msg = f"Error in send_form: {str(e)}"
        logging.error(error_msg)
        return {
            "status": "error",
            "message": str(e)
        }, 500

@app.route('/api/check-topic', methods=['POST'])
async def check_topic():
    try:
        data = await request.get_json()
        user_id = data.get('userId')

        if not user_id:
            return jsonify({"hasTopic": False}), 200

        db = await aiosqlite.connect(db_path)
        try:
            async with db.execute('SELECT topic_id FROM users WHERE chat_id = ?', (user_id,)) as cursor:
                row = await cursor.fetchone()

                if not row:
                    return jsonify({"hasTopic": False}), 200

                try:
                    await bot.get_chat(GROUP_ID)
                    await bot.get_forum_topic(GROUP_ID, row[0])
                    return jsonify({"hasTopic": True}), 200
                except telebot.asyncio_helper.ApiTelegramException as e:
                    if "chat not found" in str(e):
                        return jsonify({"hasTopic": False, "error": "Group not found"}), 200
                    elif "message thread not found" in str(e):
                        return jsonify({"hasTopic": False, "error": "Topic not found"}), 200
                    else:
                        return jsonify({"hasTopic": False, "error": "API Error"}), 200
        finally:
            await db.close()

    except Exception as e:
        logging.error(f"Error in check_topic: {str(e)}")
        return jsonify({"error": str(e)}), 500

async def main():
    global db_path
    print("–ë–æ—Ç –∏ Quart —Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω—ã!")
    setup_logging()
    db_object = await init_db(db_path)
    rules_checker = [
        {"type": "private", "timeout": timedelta(hours=1), "action": days_ping}
    ]
    rules_checker.append({"type": "weekend", "day": 5} if is_weekend_have else {"type": "none"})
    rules_checker.append({"type": "weekend", "day": 6} if is_weekend_have else {"type": "none"})
    rules_checker.append({"type": "latehour", "hour": 19} if is_latehour_have else {"type": "none"})
    bot.add_custom_filter(asyncio_filters.StateFilter(bot))
    # bot.setup_middleware(RateLimitMiddleware(limit_messages=5,limit_albums=3,time_window=40, bot=bot))
    bot.setup_middleware(StateMiddleware(bot))
    bot.setup_middleware(UserTimeChecker(GROUP_ID, db_path))
    bot.setup_middleware(DatabaseMiddleware(db_object, bot, GROUP_ID))
    bot.setup_middleware(AlbumMiddleware())
    while True:
        try:
            if scheduler.running == False:
                scheduler.start()
            config = Config()
            config.bind = ["0.0.0.0:{{ port }}"]  # –ò–∑–º–µ–Ω–µ–Ω –ø–æ—Ä—Ç –Ω–∞ 5002

            cert_path = "/etc/letsencrypt/live/shopoutcast.ru/fullchain.pem"
            key_path = "/etc/letsencrypt/live/shopoutcast.ru/privkey.pem"

            if os.path.exists(cert_path) and os.path.exists(key_path):
                print("–°–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—ã –Ω–∞–π–¥–µ–Ω—ã, –∑–∞–ø—É—Å–∫–∞–µ–º —Å HTTPS")
                config.certfile = cert_path
                config.keyfile = key_path
            else:
                print("–°–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã, –∑–∞–ø—É—Å–∫–∞–µ–º –±–µ–∑ HTTPS")

            bot_task = asyncio.create_task(bot.infinity_polling(allowed_updates=[
                'message',
                'edited_message',
                'channel_post',
                'edited_channel_post',
                'message_reaction',
                'message_reaction_count',
                'callback_query',
                'chat_member'
            ]))
            web_task = asyncio.create_task(serve(app, config))
            await asyncio.gather(bot_task, web_task)

        except Exception as e:
            logging.error(f"An error occurred –∫–æ–¥ –æ—à–∏–±–∫–∏: {e}", exc_info=True)
            await db_object.close()
            if scheduler.running:
                scheduler.shutdown()